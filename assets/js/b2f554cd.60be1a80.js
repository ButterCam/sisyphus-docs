"use strict";(self.webpackChunksisyphus_docs=self.webpackChunksisyphus_docs||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"new-docker-plugin","metadata":{"permalink":"/blog/new-docker-plugin","editUrl":"https://github.com/ButterCam/sisyphus-docs/edit/main/blog/2022-10-18-new-docker-plugin.md","source":"@site/blog/2022-10-18-new-docker-plugin.md","title":"New docker plugin","description":"In Sisyphus 1.5.20, we have further optimized the Docker plugin to make it easier to use.","date":"2022-10-18T00:00:00.000Z","formattedDate":"October 18, 2022","tags":[{"label":"docker","permalink":"/blog/tags/docker"},{"label":"sisyphus-project-plugin","permalink":"/blog/tags/sisyphus-project-plugin"},{"label":"gradle","permalink":"/blog/tags/gradle"},{"label":"release","permalink":"/blog/tags/release"}],"readingTime":4.69,"hasTruncateMarker":true,"authors":[{"name":"HIGAN","title":"Sisyphus maintainer","url":"https://github.com/devkanro","imageURL":"https://github.com/devkanro.png","key":"higan"}],"frontMatter":{"slug":"new-docker-plugin","title":"New docker plugin","authors":["higan"],"tags":["docker","sisyphus-project-plugin","gradle","release"]}},"content":"In Sisyphus 1.5.20, we have further optimized the Docker plugin to make it easier to use.\\n\\nThe main tweaks include changes to the base Docker plugin, automatic Dockerfile generation, and support for Spring\\nlayered jar builds.\\n\\n\x3c!--truncate--\x3e\\n\\n## How it started\\n\\nWe\'ve been using GitHub Action as our CI tool, and when we create a PullRequest, CI automatically compiles a SNAPSHOT\\nversion of the image to deploy the test environment. After the PR merge, the CI compiles a SNAPSHOT version with branch\\nnames to deploy the beta environment. The final deployment image is actually compiled when the Release is created.\\n\\nAs you can see, we need to build the image three times in the whole CI pipeline, and each build takes about 40 minutes,\\nwhich can take close to two hours from the time the PR is raised to the final release.\\n\\nAnd due to the recent internal CI flow resource consumption problem, our backend service has been taking three hours for\\none build, so until the CI flow resource problem is solved, we have to optimize our CI pipeline.\\n\\n## How it optimized\\n\\nFirst of all, in the actual use process, the SNAPSHOT version of the PR build image is generally not used, most cases\\nare used to deploy the test environment of the developer\'s local build image, so we can remove the PR image build step,\\njust do some code checking.\\n\\nSecond, the SNAPSHOT version built for each branch is actually the same as the RELEASE version in the final release, but\\ndue to the subtle differences in the build environment, the compilation result is not cached, and the branch building\\nstill needs to be run again for each release. So for this, we plan to reuse the image compiled from the previous branch\\nbuilt.\\n\\nIn previous versions, we used [palantir/gradle-docker](https://github.com/palantir/gradle-docker) as our base Docker\\nplugin, for which we also optimized the design of the tag task.\\n\\nHowever, during this CI pipeline optimization, we found some shortcomings, such as no `docker save` support and no easy\\nway to get the current build image ID.\\n\\nSo we switched the base Docker plugin\\nto [bmuschko/gradle-docker-plugin](https://github.com/bmuschko/gradle-docker-plugin), which provides more underlying\\noperational capabilities.\\n\\n## Generated dockerfile with Spring Layered Jar\\n\\nIn our previous usage, our Dockerfile was written manually, while the new base Docker plugin provides the ability to\\nautomatically generate a Dockerfile, so we intend to generate Dockerfile automatically by the plugin.\\n\\nPreviously, our Dockerfile was written according to Spring Boot\'s Layered Jar hierarchy, which looked something like\\nthis.\\n\\n```dockerfile\\nFROM amazoncorretto:17 as builder\\nARG PROJECT_NAME\\nARG PROJECT_VERSION\\nENV PROJECT_NAME=$PROJECT_NAME\\nENV PROJECT_VERSION=$PROJECT_VERSION\\n\\nCOPY \\"${PROJECT_NAME}-${PROJECT_VERSION}.jar\\" application.jar\\nRUN java -Djarmode=layertools -jar application.jar extract\\n\\nFROM --platform=linux/amd64 amd64/amazoncorretto:17\\n\\nARG PROJECT_NAME\\nARG PROJECT_VERSION\\nENV PROJECT_NAME=$PROJECT_NAME\\nENV PROJECT_VERSION=$PROJECT_VERSION\\n\\nCOPY --from=builder dependencies/ ./\\nRUN true\\nCOPY --from=builder spring-boot-loader/ ./\\nRUN true\\nCOPY --from=builder sisyphus-dependencies/ ./\\nRUN true\\nCOPY --from=builder butter-dependencies/ ./\\nRUN true\\nCOPY --from=builder snapshot-dependencies/ ./\\nRUN true\\nCOPY --from=builder application/ ./\\n\\nENTRYPOINT [\\"java\\", \\"org.springframework.boot.loader.JarLauncher\\"]\\n```\\n\\nSpring Boot 2.3 added support\\nfor [Layered Jar](https://spring.io/blog/2020/08/14/creating-efficient-docker-images-with-spring-boot-2-3), which allows\\nyou to layer dependencies and application packages. We use this feature in Dockerfile to layer different dependencies\\naccording to their update frequency, putting infrequently updated dependencies in the bottom layer and frequently\\nupdated dependencies in the top layer, so that when we upgrade only the frequently changed components, we can reuse the\\nprevious bottom image, thus speeding up the image build.\\n\\nSo we used Docker\'s builder mode to decompress the Layered Jar to a temporary Docker pod, and then copied the\\ndecompressed layers into the final image in hierarchical order.\\n\\n```kotlin\\ntasks.withType<BootJar> {\\n    layered {\\n        application {\\n            intoLayer(\\"spring-boot-loader\\") {\\n                include(\\"org/springframework/boot/loader/**\\")\\n            }\\n            intoLayer(\\"application\\")\\n        }\\n        dependencies {\\n            intoLayer(\\"snapshot-dependencies\\") {\\n                include(\\"*:*:*SNAPSHOT\\")\\n            }\\n            intoLayer(\\"sisyphus-dependencies\\") {\\n                include(\\"com.bybutter.sisyphus.*:*:*\\")\\n            }\\n            intoLayer(\\"butter-dependencies\\") {\\n                include(\\"com.bybutter.*:*:*\\")\\n            }\\n            intoLayer(\\"dependencies\\")\\n        }\\n        layerOrder = listOf(\\n            \\"dependencies\\",\\n            \\"spring-boot-loader\\",\\n            \\"sisyphus-dependencies\\",\\n            \\"butter-dependencies\\",\\n            \\"snapshot-dependencies\\",\\n            \\"application\\"\\n        )\\n    }\\n}\\n```\\n\\nIn the above configuration, we have roughly divided the code into 6 layers:\\n\\n1. dependencies  \\n   This layer contains all the third-party dependencies.\\n2. spring-boot-loader  \\n   This layer contains the Spring Boot loader.\\n3. sisyphus-dependencies  \\n   This layer contains all the Sisyphus dependencies. Sisyphus often does some iterative upgrades due to business needs,\\n   so it is separated from the common dependencies.\\n4. butter-dependencies  \\n   This layer contains all our internal dependencies and is closely related to the business.\\n5. snapshot-dependencies  \\n   This layer contains all the SNAPSHOT version dependencies as snapshot versions, which may change during development.\\n6. application  \\n   This layer contains the business code and is the most frequently updated layer.\\n\\nThe new Sisyphus Docker plugin automatically reads the layering information from the bootJar task and generates a\\nlayered decompression task to decompress the bootJar layering to the Docker build\'s working directory.\\n\\nThen the `dockerfile` task generates the Dockerfile needed for the build.\\n\\n```dockerfile\\nARG PROJECT_NAME\\nARG PROJECT_VERSION\\nFROM amazoncorretto:17\\nENV PROJECT_NAME=$PROJECT_NAME\\nENV PROJECT_VERSION=$PROJECT_VERSION\\nCOPY dependencies/ ./\\nRUN true\\nCOPY spring-boot-loader/ ./\\nRUN true\\nCOPY sisyphus-dependencies/ ./\\nRUN true\\nCOPY butter-dependencies/ ./\\nRUN true\\nCOPY snapshot-dependencies/ ./\\nRUN true\\nCOPY application/ ./\\nRUN true\\nENTRYPOINT [\\"java\\", \\"org.springframework.boot.loader.JarLauncher\\"]\\n```\\n\\n## Apply to CI pipeline\\n\\nThe new Docker plugin automatically generates a file containing the image IDs when it is built, and we collect these\\nimage IDs during the build of the branch SNAPSHOT version and store them in an attachment to the draft release.\\n\\nRe-tagging these image IDs with the release version during the Release build pipeline to saves image build time.\\n\\nIn fact, at the beginning, our original design was to save the branch SNAPSHOT image as a file via docker save and then\\nload it and re-tag as release version, but this would result in an oversized Release attachment, so we finally chose to\\nre-tag it using the image ID."}]}')}}]);